"""
Get To The Point: Summarization with Pointer-Generator Networks
https://arxiv.org/abs/1704.04368

The CNN / DailyMail Dataset is an English-language dataset containing just over
300k unique news articles as written by journalists at CNN and the Daily Mail.
The current version supports both extractive and abstractive summarization,
though the original version was created for machine reading and comprehension
and abstractive question answering.

Homepage: https://github.com/abisee/cnn-dailymail
"""
import numpy as np
import sacrebleu
from nltk import tokenize
from rouge_score import rouge_scorer, scoring
from lm_eval.base import rf, Task
from lm_eval.metrics import mean


_CITATION = """
@inproceedings{see2017get,
  title={Get To The Point: Summarization with Pointer-Generator Networks},
  author={See, Abigail and Liu, Peter J and Manning, Christopher D},
  booktitle={Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)},
  pages={1073--1083},
  year={2017}
}
"""


class CNNDailyMailGen(Task):
    VERSION = 0
    DATASET_PATH = "cnn_dailymail"
    DATASET_NAME = '3.0.0'

    NUM_TOKENS_TO_GENERATE = 100

    def has_training_docs(self):
        return True

    def has_validation_docs(self):
        return True

    def has_test_docs(self):
        return True

    def training_docs(self):
        if self.has_training_docs():
            # We cache training documents in `self._training_docs` for faster
            # few-shot processing. If the data is too large to fit in memory,
            # return the training data as a generator instead of a list.
            if self._training_docs is None:
                self._training_docs = list(self.dataset["train"])
            return self._training_docs

    def validation_docs(self):
        if self.has_validation_docs():
            return self.dataset["validation"]

    def test_docs(self):
        if self.has_test_docs():
            return self.dataset["test"]

    def doc_to_text(self, doc):
        """Use TL;DR appended to article to induce summarization behavior."""
        return f"{doc['article']} TL;DR:"

    def doc_to_target(self, doc):
        return " " + doc["highlights"]

    def construct_requests(self, doc, ctx):
        """Uses RequestFactory to construct Requests and returns an iterable of
        Requests which will be sent to the LM.

        :param doc:
            The document as returned from training_docs, validation_docs, or
            test_docs.
        :param ctx: str
            The context string, generated by fewshot_context. This includes the natural
            language description, as well as the few shot examples, and the question
            part of the document for `doc`.
        """
        # TODO: Implement top-k sampling, as in the original GPT-2 evaluation.
        return rf.greedy_until(ctx, None, self.NUM_TOKENS_TO_GENERATE)

    def process_results(self, doc, results):
        """Take a single document and the LM results and evaluates, returning a
        dict where keys are the names of submetrics and values are the values of
        the metric for that one document

        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param results:
            The results of the requests created in construct_requests.
        """
        # Extract only first 3 sentences from first 100 tokens, as in OpenAI
        # GPT-2 eval. Then join via newlines
        completion_sentences = tokenize.sent_tokenize(results[0].strip())
        completion = "\n".join(completion_sentences[:3])
        ref = doc["highlights"]

        # Process the sentence-level BLEU and ROUGE for similarity measures.

        # BLEU
        bleu_score = self.bleu([[ref]], [completion])

        # ROUGE-N
        rouge_score = self.rouge([ref], [completion])
        # ROUGE-1
        rouge1_score = rouge_score["rouge1"]
        rouge2_score = rouge_score["rouge2"]
        rougeL_score = rouge_score["rougeLsum"]

        return {
            "bleu": bleu_score,
            "rouge1": rouge1_score,
            "rouge2": rouge2_score,
            "rougeL": rougeL_score,
        }

    def aggregation(self):
        """
        :returns: {str: [metric_score] -> float}
            A dictionary where keys are the names of submetrics and values are
            functions that aggregate a list of metric scores
        """
        return {
            "bleu": mean,
            "rouge1": mean,
            "rouge2": mean,
            "rougeL": mean,
        }

    def higher_is_better(self):
        return {
            "bleu": True,
            "rouge1": True,
            "rouge2": True,
            "rougeL": True,
        }

    def bleu(self, refs, preds):
        """
        Returns `t5` style BLEU scores. See the related implementation:
        https://github.com/google-research/text-to-text-transfer-transformer/blob/3d10afd51ba97ac29eb66ae701eca274488202f7/t5/evaluation/metrics.py#L41

        :param refs:
            A `list` of `list` of reference `str`s.
        :param preds:
            A `list` of predicted `str`s.
        """
        score = sacrebleu.corpus_bleu(
            preds,
            refs,
            smooth_method="exp",
            smooth_value=0.0,
            force=False,
            lowercase=False,
            tokenize="intl",
            use_effective_order=False,
        ).score
        return score

    def rouge(self, refs, preds):
        """
        Returns `t5` style ROUGE scores. See the related implementation:
        https://github.com/google-research/text-to-text-transfer-transformer/blob/3d10afd51ba97ac29eb66ae701eca274488202f7/t5/evaluation/metrics.py#L68

        TODO: wrap rouge into a separate function in
        `metrics`.

        :param refs:
            A `list` of reference `strs`.
        :param preds:
            A `list` of predicted `strs`.
        """
        rouge_types = ["rouge1", "rouge2", "rougeLsum"]
        scorer = rouge_scorer.RougeScorer(rouge_types)
        # Add newlines between sentences to correctly compute `rougeLsum`.

        def _prepare_summary(summary):
            summary = summary.replace(" . ", ".\n")
            return summary

        # Accumulate confidence intervals.
        aggregator = scoring.BootstrapAggregator()
        for ref, pred in zip(refs, preds):
            ref = _prepare_summary(ref)
            pred = _prepare_summary(pred)
            aggregator.add_scores(scorer.score(ref, pred))
        result = aggregator.aggregate()
        return {type: result[type].mid.fmeasure * 100 for type in rouge_types}
